# 다이나믹 프로그래밍

연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘을 작성하기 위해 사용하는 대표적인 방법.

다이나믹 프로그래밍 사용 조건
- 큰 문제를 작은 문제로 나눌 수 있다.
- 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

- 메모이제이션(=캐싱) : DP 구현 방법 중 한 종류, 한 번 구한 겨과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법

피보나치 수열 재귀 함수 + 메모이제이션 + 탑다운
```python
d = [0] * 100

def fibo(x):
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]
print(fibo(99))
```
-> 재귀함수 대신 반복문을 사용해 오버헤드를 줄일 수 있다.
-> 큰 문제가 해결되기 위해 작은 문제를 호출 : 탑다운
-> recursion depth 오류 발생시 setrecursionlimit() 함수를 호출해 재귀 제한 완화

피보나치 수열 반복문 + 바텀업
```python
d = [0] * 100

d[1] = 1
d[2] = 1
n = 99
for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]

print(d[n])
```
-> 작은 문제부터 차근차근 답을 도출 : 바텀업 (DP의 전형적인 형태)

## [문제] 1로 만들기
> x연산 방식은 4가지
> 1. 5로 나누어 떨어지면 5로 나눈다.
> 2. 3으로 나누어 떨어지면 3으로 나눈다.
> 3. 2으로 나누어 떨어지면 2으로 나눈다.
> 4. x에서 1을 뺀다
> 연산 사용 횟수의 최솟값을 구하라.

```python
# 교재 풀이
n = int(input())

d = [0] * 30001

for i in range(2, n + 1):
    d[i] = d[i - 1] + 1
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)

print(d[n])
```
-> 점화식으로 표현하여 구현

## [문제] 개미 전사
> 개미전사가 일직선으로 이어진 여러 식량창고를 선택적으로 약탈
> 최소 한 칸 이상 떨어진 식량 창고를 약탈해야할 때, 획득 식량의 최댓값을 구하라.


```python
# 교재 풀이
n = int(input())
array = list(map(int, input().split()))

d = [0] * 100

d[0] = array[0]
d[1] = max(array[0], array[1])
for i in range(2, n):
    d[i] = max(d[i - 1], d[i - 2] + array[i])

print(d[n - 1])
```
-> 특정 위치의 식량을 약탈할지 말지는 2가지 경우만 고려하면 된다.

## [문제] 바닥 공사
> 가로 n, 세로 2인 직사각형 바닥이 있을 때, 1*2, 2*1, 2*2 덮개를 이용해 채우려고 한다.
> 채울 수 있는 모든 경우의 수를 구하라.

```python
# 교재 풀이
n = int(input())

d = [0] * 1001
d[1] = 1
d[2] = 3
for i in range(3, n + 1):
    d[i] = (d[i - 1] + 2 * d[i - 2]) % 796796

print(d[n])
```
-> 덮개가 최대 2*2이기 때문에 i-1, i-2 * 2 두가지 경우로만 고려하면 된다.

## [문제] 효율적인 화폐 구성
> n가지 종류의 화폐들의 개수를 최소한으로 이용해 그 가치의 합이 m원이 되도록 한다.
> 각 화폐는 개수 제한이 없으며, 사용 화폐 구성은 같지만 순서만 다른 것은 같은 경우로 구분한다.

```python
# 교재 풀이
n, m = map(int, input().split())
array = []
for i in range(n):
    array.append(int(input()))

d = [10001] * (m + 1)
d[0] = 0

for i in range(n):
    for j in range(array[i], m + 1):
        if d[j - array[i]] != 10001:
            d[j] = min(d[j], d[j - array[i]] + 1)

if d[m] == 10001:
    print(-1)
else:
    print(d[m])
```
-> 모든 화폐 단위에 대해 점화식을 적용